#!/usr/bin/env node
"use strict"
const fs = require('fs')
const childproc = require('child_process')
const {basename, normalize, dirname} = require('path')

function isfile(filename) {
  try { return fs.statSync(filename).isFile() } catch (_) { return false }
}

function parseargs(args, defaultOpts) {
  let optsEnded = false, m
  const opts = defaultOpts ? Object.extend({},defaultOpts) : {}
  const re = /^-{1,2}([^=:]+)(?:\s*[=:]\s*(.+)|)$/
  let argStartIndex = 0
  for (let L = args.length; argStartIndex != L; ++argStartIndex) {
    let arg = args[argStartIndex]
    if (arg == '--') {
      ++argStartIndex
      break
    } else if (arg[0] != '-') {
      break
    }
    let m = re.exec(arg)
    opts[m[1]] = m[2] === undefined ? true : m[2]
  }
  return {opts, args: argStartIndex == 0 ? args : args.slice(argStartIndex)}
}

// process state
const NOT_STARTED = 0, RUNNING = 1, EXITED = 2

function terminate(proc) { // :Promise<void>
  if (!proc || proc.state != RUNNING) {
    return Promise.resolve()
  }
  return new Promise((resolve, reject) => {
    const signals = ['SIGTERM', 'SIGINT', 'SIGKILL']
    const timeout = 200

    let signalIndex = 0
    let killTimer = null
    let timeoutReached = false

    proc.once('exit', () => {
      clearTimeout(killTimer)
      if (!timeoutReached) {
        resolve()
      }
    })

    let kill = function() {
      let sig = signals[signalIndex++]
      if (sig == undefined) {
        timeoutReached = true
        return reject(new Error('timeout'))
      }
      proc.kill(sig)
      clearTimeout(killTimer)
      killTimer = setTimeout(kill, timeout)
    }

    kill()
  })
}

function spawn(args) { // :Promise<ChildProcess>
  return new Promise((resolve, reject) => {
    const opts = {stdio:'inherit'}
    const proc = childproc.spawn(args[0], args.slice(1), opts)
    proc.state = NOT_STARTED
    let cleanup = null

    let onexit = function() {
      proc.state = EXITED
      if (cleanup) {
        process.removeListener('exit', cleanup)
        process.removeListener('error', cleanup)
      }
    }

    const checkalive = function() {
      if (proc.state == NOT_STARTED) {
        if (proc.pid !== undefined) {
          proc.state = RUNNING
          proc.terminate = terminate.bind(null, proc); // :Promise<void>
          cleanup = function() { proc.kill('SIGKILL') }
          process.on('exit', cleanup)
          process.on('error', cleanup)
          resolve(proc)
        } else {
          process.nextTick(checkalive)
        }
      }
    }
    process.nextTick(checkalive)

    proc.on('exit', onexit)

    const onErr = function(err) {
      if (proc.state == NOT_STARTED) {
        onexit()
        reject(err)
        proc.removeListener('error', onErr)
      }
    }
    proc.on('error', onErr)
  })
}

function mtime(file) {
  try {
    const st = fs.statSync(file)
    if (st.isFile()) {
      return st.mtime.getTime()
    }
  } catch (_) {}
  return 0
}

function main() {
  const {opts, args} = parseargs(process.argv.slice(2))
  const progpath = process.env._ || basename(process.argv[1])
  const progname = basename(progpath)
  const askedForHelp = opts.h || opts.help
  let reactionTime = 100

  if (askedForHelp || args.length == 0) {
    const desc0 = [
      'Automatically spawn and manage processes as file changes.',
    ], desc1 = [
       `Usage: ${progpath} [options] <file> ... [-- <cmdpattern>]`
      ,'options:'
      ,'  -h[elp]             Show description and detailed help for this program.'
      ,'  -v[erbose]          Print some details to stdout.'
      ,'  -s[top]             Exit with an error if <file> disappears from the file system.'
      ,'  -c[lear-screen]     Clear terminal screen before (re)starting the command.'
      ,`  -r[eact-in]=<msec>  React within <msec> to file changes. Defaults to ${reactionTime}.`
      ,'  -no-banner          Don\'t print banner to stdout when restarting the command.'
    ], desc2 = [
       ''
      ,'<file>        Files to watch for changes'
      ,''
      ,'<cmdpattern>  Pattern for command to execute, replacing ":" with <file>.'
      ,'              If not specified or if <cmdpattern> does not include a ":"'
      ,'              argument, <file> is executed with <cmdpattern> as arguments.'
      ,'              If you need to pass an argument of value ":", use "\\" which'
      ,'              will be expanded to ":" rather than <file>.'
      ,''
      ,'Examples: (INVOCATION  # COMMAND EXECUTED)'
      ,`  ${progname} foo.sh                      # foo.sh`
      ,`  ${progname} foo.sh vars.sh              # foo.sh`
      ,`  ${progname} foo.sh -- : bar             # foo.sh bar`
      ,`  ${progname} foo.js -- node --check :    # node --check foo.js`
      ,`  ${progname} foo.py -- python : \\\\: a  # python foo.py : a`
      ,''
    ];
    if (askedForHelp) {
      console.error(desc0.concat(desc1.concat(desc2)).join('\n'))
      process.exit(0)
    } else {
      console.error(desc1.join('\n') + `\nTry "${progpath} -help" for more information`)
      process.exit(1)
    }
  }

  const die = function(msg) {
    console.error(`${progpath}: ${msg}`)
    process.exit(1)
  }

  const verbose = opts.v || opts.verbose
  const logverbose = verbose ? console.log.bind(console) : function(){}

  if ('r' in opts || 'react-in' in opts) {
    let v = parseInt(opts.r || opts['react-in'])
    if (typeof v != 'number' || isNaN(v) || v <= 0) {
      die(`invalid -react-in value: ${opts.r || opts['react-in']}`)
    }
    reactionTime = v
  }

  const p = args.indexOf('--')
  const infiles = p == -1 ? args : args.slice(0, p)
  const runargs = p == -1 ? infiles[0] : args.slice(p + 1)

  if (infiles.length == 0) {
    die('no input files')
  }

  // const filename = args[0]
  // const path = normalize(filename)
  // const dir = dirname(args[0])

  const fileslot = Symbol('fileslot')

  // if (!isfile(filename)) {
  //   console.error(filename, 'is not a file')
  //   process.exit(1)
  // }

  // parse command
  let fileslotInCmd = true
  let cmd = [fileslot]
  if (runargs.length > 0) {
    cmd = runargs.map(arg => {
      return (arg == ':') ? fileslot :
             (arg == '\\:') ? ':' :
             arg
    })
    fileslotInCmd = cmd.indexOf(fileslot) != -1
  }

  function fmtcmd(filename) {
    return cmd.map(c =>
      c == fileslot ? (filename ? JSON.stringify(filename) : '<file>')
                    : JSON.stringify(c) ).join(' ')
  }

  logverbose('<cmdpattern> =', fmtcmd())

  const clearScreen = (opts.c || opts['clear-screen']) ?
    function() { process.stdout.write('\x1b[2J') } : function(){};

  const hline = '━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━'+
                '━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━';
  const space = '                                        '+
                '                                        ';

  let needCR = false

  const resetLine = function() {
    if (needCR) {
      process.stdout.write('\r')
      needCR = false
    }
  }

  const printHeaderStarting = function(name) {
    if (!fileslotInCmd) { name = cmd.join(' ') }
    resetLine()
    process.stdout.write(
      hline.substr(0,20) + ` ${name} changed -- restarting...`
    )
    needCR = true
  }

  const printFooterEnded = function(code) {
    resetLine()
    const hline20 = hline.substr(0,20)
    process.stdout.write(`${hline20} exit ${code} ${hline20}`)
    needCR = true
  }

  const printHeaderStarted = function(name, pid) {
    if (!fileslotInCmd) { name = cmd.join(' ') }
    const time = (new Date()).toLocaleTimeString()
    const timehline = hline.substr(0, time.length)

    const namelen = Math.max(40, name.length)
    if (namelen > name.length) {
      name += space.substr(0, namelen - name.length)
    }
    name += pid.toString()

    const namehline = hline.substr(0, name.length)

    resetLine()
    process.stdout.write(
      '┏━' + timehline + '━┳━' + namehline + '━┓\n' +
      `┃ ${time} ┃ ${name} ┃\n` +
      '┗━' + timehline + '━┻━' + namehline + '━┛\n'
    )
  }

  const spawnfile = function(filename) {
    logverbose('\nspawn', fmtcmd(filename))
    const args = cmd.map(c => c == fileslot ? filename : c)
    return spawn(args).catch(die).then(proc => {
      if (!opts['no-banner']) {
        printHeaderStarted(basename(filename), proc.pid)
      }
      proc.once('exit', (code, signal) => {
        if (signal === null && !opts['no-banner']) {
          printFooterEnded(code)
        } // else: process was terminated by signal
      })
      return proc
    })
  }

  function inputMTime() {
    return infiles.reduce((maxval, file) => {
      return Math.max(maxval, mtime(file))
    }, 0)
  }

  let lastMTime = inputMTime()

  clearScreen()
  spawnfile(infiles[0]).then(proc => {

    let isRestarting = false

    const restart = function(name, path) {
      // (re)start process
      if (isRestarting) {
        return
      }
      isRestarting = true
      setTimeout(() => {
        proc.terminate().catch(die).then(() => {
          isRestarting = false
          clearScreen()
          if (!opts['no-banner']) {
            printHeaderStarting(name)
          }
          return spawnfile(path).then(p => (proc = p))
        })
      }, reactionTime)
    }

    var watchers = new Map()

    function stopWatching(filename) {
      let watcher = watchers.get(filename)
      if (watcher) {
        watcher.close()
      }
    }

    function startWatching(filename, isPrimaryInfile) {
      let watcher = watchers.get(filename)
      if (watcher) {
        watcher.close()
      }
      watchers.set(filename, fs.watch(filename, {}, (event, name) => {
        logverbose('fsevent', event, name)
        let filename2 = dirname(filename) + '/' + name
        if (isfile(filename2)) {
          // Sometimes we get multiple change events when the file has changed
          // only once. We compare the mtime of the file to filter out
          // redundant fs events.
          const currMTime = mtime(filename)
          // const currMTime = inputMTime()
          if (currMTime != lastMTime) {
            lastMTime = currMTime

            if (event != 'change' || filename !== filename2) {
              stopWatching(filename)
              setImmediate(() => startWatching(filename2, isPrimaryInfile))
            }

            if (isPrimaryInfile) {
              restart(name, filename2)
            } else {
              restart(name, infiles[0])
            }
          }
        } else {
          lastMTime = 0
          proc.terminate().catch(die)
          if (opts.s || opts.stop) {
            stopWatching(filename)
            console.error(name, 'disappeared')
            process.exit(1)
          }
        }
      }))
    }

    // watch input files
    infiles.forEach((infile, infileIndex) => {
      logverbose('watch', infile)
      startWatching(infile, infileIndex == 0)
    })
  }) // infiles.forEach

}

main()

